import subprocess
import shlex
from typing import Dict, Any, Tuple
from pydantic import BaseModel, Field

class CommandArgs(BaseModel):
    cmd: str = Field(..., description="The command to run in shell.")
    name: Optional[str] = Field(None, description="The name for the command if it needs to be saved as a python file.")

class CommandTool:
    def __init__(self, name: str, description: str, args_schema: BaseModel):
        self.name = name
        self.description = description
        self.args_schema = args_schema

    def run_command(self, cmd: str) -> Tuple[str, str]:
        cmd_parts = shlex.split(cmd)
        result = subprocess.run(cmd_parts, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output = result.stdout.decode()
        error = result.stderr.decode()
        return output, error

    def save_command_as_file(self, cmd: str, name: str) -> None:
        content = f\"\"\"
import subprocess
import shlex

def run_command(cmd):
    cmd_parts = shlex.split(cmd)
    result = subprocess.run(cmd_parts, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output = result.stdout.decode()
    error = result.stderr.decode()

    return output, error

if __name__ == "__main__":
    output, error = run_command(\"{cmd}\")

    if output:
        print("Output:\\n", output)
    if error:
        print("Error:\\n", error)
\"\"\"
        with open(f"{name}.py", "w") as file:
            file.write(content)

    def execute(self, args: Dict[str, Any]) -> Tuple[str, str]:
        cmd = args.get("cmd")
        name = args.get("name")
        if name is not None:
            self.save_command_as_file(cmd, name)
        return self.run_command(cmd)

def create_command_tool():
    name = "CommandTool"
    description = "A tool to run shell commands and optionally save them as python files."
    args_schema = CommandArgs()
    return CommandTool(name, description, args_schema)
